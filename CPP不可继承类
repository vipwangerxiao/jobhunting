//利用友元类和虚拟继承完成


class Lock
{
  private:
  Lock(){}
  Lock(const Lock&a){}//如果不把拷贝构造函数声明为私有的,B中可以利用
                      // B():Lock(*(new A)){}来完成构造函数的定义,此时调用的是Lock的拷贝构造函数,并不涉及Lock的默认构造函数,权限允许
  
  friend class A;
};

class A :pubic virtual Lock
{
 //此时父类的构造函数是可以是public的,那么可以直接调用A的构造函数生成实例对象
}

class B:public A
{
public :
 B(){}//如果此时派生类不写,即不定义构造函数,编译也可以通过,因为默认构造函数什么也不会合成,但是以后如果需要定义B的实例,会调用Lock构造函数,依然会
      //编译错
      //
      //
      //换一种说法是,如果不写构造函数也不生成对象,编译不会出错,因为合成的构造函数,什么也不做,因为不需要,所以是trival
      //否则就会调用Lock的构造函数,编译出错
      //

};



参数重载加const只对引用和指针指针指向的对象是不是const构成重载,因为这时可以保护变量对象
如果是值传递的话,变量引用的都是一个临时值,是赋值过来的,不涉及变量本身,const不构成重载,这个时候重载是错误的.


